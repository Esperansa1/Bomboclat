---
phase: 01-scaffold
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/main.rs
autonomous: true
requirements:
  - CONN-02
  - PROT-03

must_haves:
  truths:
    - "`cargo build` succeeds with zero errors"
    - "Cargo.toml contains tokio, tokio-tungstenite, reqwest, ahash, dotenvy, and a capsolver crate"
    - "src/main.rs has a #[tokio::main] entry point that compiles and runs"
  artifacts:
    - path: "Cargo.toml"
      provides: "Full dependency manifest for the trading engine"
      contains: "tokio"
    - path: "src/main.rs"
      provides: "Async Tokio entry point"
      contains: "#[tokio::main]"
  key_links:
    - from: "Cargo.toml"
      to: "src/main.rs"
      via: "cargo build resolves and compiles all deps"
      pattern: "tokio.*features.*full"
---

<objective>
Initialize the Rust binary crate with all required dependencies and a working Tokio async entry point.

Purpose: Establishes the compilation foundation every subsequent phase builds on. All library choices are locked by project decisions — this is not exploratory work.
Output: A compilable `Cargo.toml` + minimal `src/main.rs` that enters a Tokio runtime.
</objective>

<execution_context>
@C:/Users/oresp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/oresp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cargo.toml with locked dependency set</name>
  <files>Cargo.toml</files>
  <action>
Create `Cargo.toml` at the project root as a binary crate (not a workspace). Use the following exact dependency set as specified in the roadmap:

```toml
[package]
name = "csgoroll-sniper"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "csgoroll-sniper"
path = "src/main.rs"

[dependencies]
tokio = { version = "1", features = ["full"] }
tokio-tungstenite = { version = "0.24", features = ["native-tls"] }
reqwest = { version = "0.12", features = ["json", "native-tls"] }
ahash = "0.8"
dotenvy = "0.15"
# CapSolver: use capsolver-rs if it resolves on crates.io; otherwise use the official
# capsolver crate. Check: `cargo search capsolver` — use whichever resolves.
# If neither resolves, add a stub dependency placeholder and document in SUMMARY.
capsolver = "0.1"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
```

Notes on dependency choices (per locked project decisions):
- `tokio` with `features = ["full"]`: full async runtime, required for WebSocket + HTTP concurrency
- `tokio-tungstenite`: async WebSocket client, integrates natively with Tokio (Phase 2 dependency)
- `reqwest`: async HTTP client with keep-alive pool support (Phase 4 dependency); native-tls over rustls to avoid OpenSSL packaging issues on Windows
- `ahash = "0.8"`: non-cryptographic hash for AHashMap — faster than std HashMap on the read-heavy whitelist hot path (locked decision)
- `dotenvy = "0.15"`: .env loading, successor to the unmaintained `dotenv` crate
- `capsolver`/`capsolver-rs`: CapSolver API client (Phase 4 dependency); verify exact crate name at runtime with `cargo search capsolver`

If `capsolver` 0.1 fails to resolve, try `capsolver-rs = "0.1"`. If both fail, add a comment placeholder `# capsolver: TBD — verify crate name with cargo search` and note in SUMMARY. The Phase 4 plan will integrate the actual API; this phase just needs the dep in the manifest.
  </action>
  <verify>
    <automated>cargo build --manifest-path C:/Users/oresp/Desktop/ActuallyRollingInMoney/Cargo.toml 2>&1 | head -5</automated>
    <manual>Verify Cargo.lock is generated and tokio, reqwest, ahash, dotenvy all appear in it</manual>
  </verify>
  <done>Cargo.toml present at project root; `cargo build` resolves all dependencies without error; Cargo.lock generated</done>
</task>

<task type="auto">
  <name>Task 2: Write minimal Tokio async entry point</name>
  <files>src/main.rs</files>
  <action>
Create `src/main.rs` with a minimal but valid Tokio async entry point. This file will be expanded in Plan 01-02 to load credentials, so leave a clear `// TODO(01-02): load credentials here` comment at the body.

```rust
#[tokio::main]
async fn main() {
    // TODO(01-02): load credentials here
    println!("CSGORoll Sniper starting...");
}
```

Do NOT add any other logic here. Do NOT use `tokio::runtime::Builder` manually — `#[tokio::main]` macro is the correct pattern for this project (per Tokio docs, `#[tokio::main]` with `features = ["full"]` is the idiomatic entry point).

Create the `src/` directory if it does not exist.
  </action>
  <verify>
    <automated>cd /c/Users/oresp/Desktop/ActuallyRollingInMoney && cargo build 2>&1 | tail -3</automated>
    <manual>Running `cargo run` prints "CSGORoll Sniper starting..." and exits 0</manual>
  </verify>
  <done>`cargo build` exits 0; `cargo run` outputs "CSGORoll Sniper starting..." and returns exit code 0</done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
cd /c/Users/oresp/Desktop/ActuallyRollingInMoney
cargo build 2>&1
cargo run 2>&1
echo "Exit code: $?"
```

Expected: build succeeds, run prints "CSGORoll Sniper starting...", exits 0.

Also confirm Cargo.toml contains all six dependency groups: tokio, tokio-tungstenite, reqwest, ahash, dotenvy, capsolver (or documented placeholder).
</verification>

<success_criteria>
1. `cargo build` succeeds with zero compilation errors
2. `cargo run` outputs "CSGORoll Sniper starting..." and exits 0
3. Cargo.toml contains tokio (features=full), tokio-tungstenite, reqwest, ahash, dotenvy, and a capsolver entry (or documented placeholder)
4. src/main.rs uses `#[tokio::main]` macro pattern
</success_criteria>

<output>
After completion, create `.planning/phases/01-scaffold/01-01-SUMMARY.md` with:
- Which capsolver crate name resolved on crates.io
- Exact versions pinned in Cargo.lock for tokio, reqwest, tokio-tungstenite
- Any dependency resolution issues encountered and how they were resolved
</output>
