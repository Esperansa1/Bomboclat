---
phase: 02-websocket-connection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ws.rs
  - src/main.rs
autonomous: true
requirements:
  - CONN-01

must_haves:
  truths:
    - "Bot establishes a WebSocket connection to CSGORoll and receives Socket.IO frames"
    - "Bot completes the Socket.IO v4 handshake (sends auth payload after server OPEN frame)"
    - "Bot prints the raw text of the first listing-related event frame to stdout then continues receiving"
    - "Bot sends Socket.IO ping frames to keep the connection alive"
  artifacts:
    - path: "src/ws.rs"
      provides: "WebSocket connect function returning a live, authenticated WS stream"
      min_lines: 60
      exports: ["connect", "WsStream"]
    - path: "src/main.rs"
      provides: "Drives ws::connect and the receive loop"
      contains: "ws::connect"
  key_links:
    - from: "src/main.rs"
      to: "src/ws.rs"
      via: "mod ws; ws::connect(&config).await"
      pattern: "ws::connect"
    - from: "src/ws.rs"
      to: "wss://api.csgoroll.com/socket.io/?EIO=4&transport=websocket"
      via: "tokio_tungstenite::connect_async with auth query param"
      pattern: "connect_async"
---

<objective>
Create the WebSocket connection module that authenticates to CSGORoll's Socket.IO v4 feed, completes the handshake, and drives a raw frame receive loop that prints the first listing event to stdout.

Purpose: This is the live data ingestion layer. Everything downstream (Phase 3 whitelist matching) depends on this module delivering raw listing frames.
Output: src/ws.rs with a connect() function and a receive loop; src/main.rs updated to drive it.
</objective>

<execution_context>
@C:/Users/oresp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/oresp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-scaffold/01-02-SUMMARY.md
@src/config.rs
@src/main.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement src/ws.rs — Socket.IO v4 connect and handshake</name>
  <files>src/ws.rs</files>
  <action>
Create `src/ws.rs` with a public `connect` async function that establishes and authenticates a WebSocket connection to CSGORoll.

**WebSocket URL and protocol:**
CSGORoll uses Socket.IO v4 over WebSocket. The URL is:
```
wss://api.csgoroll.com/socket.io/?EIO=4&transport=websocket&token={api_token}
```
Pass `config.csgoroll_api_token` as the `token` query parameter. The `csgoroll_session` value is a browser cookie — send it via the HTTP `Cookie` header in the WebSocket upgrade request.

**Connection setup:**
Use `tokio_tungstenite::connect_async_tls_with_config` (or `connect_async` with a custom `tungstenite::client::IntoClientRequest`) to set the `Cookie` header to `session={csgoroll_session}` on the upgrade request. Also set `Origin: https://csgoroll.com`.

If the simple `connect_async(url)` path does not support custom headers, use the request builder pattern:
```rust
use tokio_tungstenite::tungstenite::client::IntoClientRequest;
let mut request = url.into_client_request()?;
request.headers_mut().insert("Cookie", format!("session={}", config.csgoroll_session).parse()?);
request.headers_mut().insert("Origin", "https://csgoroll.com".parse()?);
let (ws_stream, _) = tokio_tungstenite::connect_async(request).await?;
```

**Socket.IO v4 handshake sequence:**
After the WebSocket upgrade succeeds, Socket.IO sends frames. Handle them in order:
1. Server sends `0{...}` — the OPEN frame (JSON with sid, upgrades, pingInterval, pingTimeout). Read it, parse pingInterval from JSON (or default to 25000 ms).
2. Client sends `40` — the CONNECT frame (no namespace = default `/`).
3. Server responds with `40{"sid":"..."}` — connection confirmed.
4. Start a Tokio interval task for ping: every `pingInterval` ms send `2` (PING frame) and expect `3` (PONG) back.

After step 3, the connection is authenticated and listing events will arrive.

**Socket.IO event frames:**
Listing events arrive as `42["event_name",{...}]`. The `42` prefix means: `4` = MESSAGE type, `2` = EVENT subtype. The event name for new listings on CSGORoll is `"new-item"` (verify by logging raw frames — see Task 2).

**Type alias:**
Export a type alias for the stream:
```rust
use tokio_tungstenite::WebSocketStream;
use tokio_tungstenite::MaybeTlsStream;
use tokio::net::TcpStream;

pub type WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;
```

**connect() signature:**
```rust
pub async fn connect(config: &crate::config::Config) -> Result<WsStream, Box<dyn std::error::Error + Send + Sync>>
```
After completing the handshake (steps 1-3 above), return the stream to the caller. The ping keepalive loop should be spawned as a background `tokio::spawn` task ONLY IF the stream can be split — otherwise handle pings in the main receive loop (see Task 2).

**Hot path constraint:** No allocations inside the frame-processing match arms beyond what tungstenite provides. Parse only what is needed from the OPEN frame (pingInterval).

**Imports needed:**
```rust
use futures_util::{SinkExt, StreamExt};
use tokio_tungstenite::tungstenite::Message;
```
Note: `futures_util` is a transitive dep of tokio-tungstenite — no Cargo.toml change needed.

**Error handling:** Return `Err(...)` on connection failure. Do NOT panic. The caller (Task 2 / Phase 02-02) handles reconnect.
  </action>
  <verify>
    <automated>cargo build 2>&amp;1 | tail -5</automated>
    <manual>Check that src/ws.rs compiles cleanly, exports WsStream type alias and connect() function, and contains the Socket.IO handshake sequence (send "40", await "40{...}" response)</manual>
  </verify>
  <done>
    `cargo build` exits 0. src/ws.rs exists with connect() function and WsStream type alias. The function constructs the URL with token query param, sets Cookie header, and handles the 3-step Socket.IO handshake before returning the stream.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire receive loop in main.rs — log raw frames, print first listing event</name>
  <files>src/main.rs</files>
  <action>
Update `src/main.rs` to drive the WebSocket connection and receive loop.

**Replace the current main body:**
```rust
mod config;
mod ws;

#[tokio::main]
async fn main() {
    let config = config::Config::load();

    println!("[ws] Connecting to CSGORoll WebSocket...");
    let mut stream = match ws::connect(&config).await {
        Ok(s) => {
            println!("[ws] Connected and authenticated.");
            s
        }
        Err(e) => {
            eprintln!("[ws] Connection failed: {}", e);
            std::process::exit(1);
        }
    };

    // Receive loop — Phase 02-02 will wrap this in reconnect logic
    let mut first_listing_printed = false;
    use futures_util::StreamExt;
    use tokio_tungstenite::tungstenite::Message;

    while let Some(msg) = stream.next().await {
        match msg {
            Ok(Message::Text(text)) => {
                // Socket.IO ping handling in receive loop (no split needed)
                if text == "2" {
                    // Server sent PING — respond with PONG
                    // Note: tungstenite handles WS-level pings automatically;
                    // this handles Socket.IO application-level ping ("2" frame)
                    use futures_util::SinkExt;
                    // Cannot easily send on split stream here — log and continue
                    // Phase 02-01 spawns a dedicated ping task instead
                    eprintln!("[ws] Received Socket.IO PING (unexpected in stream — ping task handles this)");
                    continue;
                }
                // Socket.IO event frame: starts with "42"
                if text.starts_with("42") && !first_listing_printed {
                    println!("[ws] First listing event: {}", &text[..text.len().min(200)]);
                    first_listing_printed = true;
                }
                // Log all frames in debug mode (truncated to 120 chars)
                eprintln!("[ws] frame: {}", &text[..text.len().min(120)]);
            }
            Ok(Message::Ping(payload)) => {
                // WS-level ping — tungstenite auto-responds; log only
                eprintln!("[ws] WS ping received");
                let _ = payload;
            }
            Ok(Message::Close(frame)) => {
                eprintln!("[ws] Server closed connection: {:?}", frame);
                break;
            }
            Ok(_) => {}
            Err(e) => {
                eprintln!("[ws] Receive error: {}", e);
                break;
            }
        }
    }

    eprintln!("[ws] Receive loop ended. Phase 02-02 will add reconnect.");
}
```

**Important:** The Socket.IO ping keepalive approach: because `SinkExt::send` requires mutable access to the sink and `StreamExt::next` requires mutable access to the stream, and a `WebSocketStream` cannot easily be used for both simultaneously without splitting, use `stream.split()` from `futures_util::StreamExt` at the top of main to get `(write, read)`. Spawn a Tokio task with `write` that sends `Message::Text("3".to_string())` (PONG) in response and sends `Message::Text("2".to_string())` (PING) on the interval. The read half goes into the receive loop.

Revised structure using split:
```rust
use futures_util::{SinkExt, StreamExt};
use tokio_tungstenite::tungstenite::Message;

let (mut write, mut read) = stream.split();

// Spawn ping keepalive task (Socket.IO application-level)
tokio::spawn(async move {
    let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(25));
    loop {
        interval.tick().await;
        if write.send(Message::Text("2".to_string())).await.is_err() {
            break;
        }
    }
});

// Receive loop on read half
let mut first_listing_printed = false;
while let Some(msg) = read.next().await {
    // ... same match arms as above but using `read`
}
```

**Verification target:** When run with valid credentials, the binary should:
1. Print `[ws] Connecting to CSGORoll WebSocket...`
2. Print `[ws] Connected and authenticated.`
3. Print `[ws] First listing event: 42[...]` once a listing arrives
4. Continue printing `[ws] frame: ...` for subsequent frames
  </action>
  <verify>
    <automated>cargo build 2>&amp;1 | tail -5</automated>
    <manual>
      Run: cargo run (with .env populated with real credentials)
      Expected output within 30 seconds:
        [ws] Connecting to CSGORoll WebSocket...
        [ws] Connected and authenticated.
        [ws] frame: 40{"sid":"..."}
        [ws] First listing event: 42["new-item",{...}]
      If credentials are not available, verify cargo build exits 0 and the code structure is correct.
    </manual>
  </verify>
  <done>
    `cargo build` exits 0. src/main.rs drives ws::connect, splits the stream, spawns a ping keepalive task, and runs a receive loop that prints the first `42[...]` frame as the listing event. The binary compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` exits 0 — no compile errors
2. `cargo clippy -- -D warnings` exits 0 or only emits expected dead_code warnings on Config fields (will resolve in Phase 3)
3. src/ws.rs exists with `pub async fn connect(config: &crate::config::Config)` and `pub type WsStream`
4. src/main.rs declares `mod ws;` and calls `ws::connect(&config).await`
5. The Socket.IO handshake sequence is present in ws.rs: sends "40" after receiving the OPEN frame, awaits the confirmed "40{...}" response
</verification>

<success_criteria>
- `cargo build` exits 0
- src/ws.rs implements the full Socket.IO v4 handshake and exposes WsStream + connect()
- src/main.rs drives the connection, splits the stream, pings on interval, and prints the first listing frame
- No panics, no unwrap() on the hot path — all errors propagated or logged
- Phase 02-02 can wrap the ws::connect() call in a reconnect loop without modifying ws.rs internals
</success_criteria>

<output>
After completion, create `.planning/phases/02-websocket-connection/02-01-SUMMARY.md`
</output>
