---
phase: 02-websocket-connection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/ws.rs
  - src/main.rs
autonomous: true
requirements:
  - CONN-01

must_haves:
  truths:
    - "Bot connects to wss://router.csgoroll.com/ws with graphql-transport-ws subprotocol"
    - "connection_init with API token sent; connection_ack received before subscribe"
    - "First received trade event printed to stdout showing trade ID, markup, price, and item name"
    - "Trade struct has all fields Phase 3 needs: id, markup_percent, total_value, can_join, status, market_name, brand, skin_name, wear, is_stattrak"
  artifacts:
    - path: "src/ws.rs"
      provides: "WebSocket connection module with Trade struct and connect_once function"
      contains: "pub struct Trade"
    - path: "Cargo.toml"
      provides: "serde and serde_json dependencies"
      contains: "serde"
  key_links:
    - from: "src/ws.rs connect_once"
      to: "wss://router.csgoroll.com/ws"
      via: "tokio_tungstenite::connect_async with custom headers"
      pattern: "Sec-WebSocket-Protocol.*graphql-transport-ws"
    - from: "connection_init payload"
      to: "csgoroll_api_token"
      via: "config.csgoroll_api_token field"
      pattern: "connection_init.*token"
    - from: "next message payload"
      to: "Trade struct"
      via: "serde_json deserialization"
      pattern: "createTrades.*trades"
---

<objective>
Implement the core WebSocket connection module for CSGORoll's graphql-transport-ws feed.

Purpose: Establish authenticated WS connection, complete the graphql-transport-ws handshake, receive and parse trade events into a typed Trade struct, and print the first event to stdout. This is the happy-path foundation — reconnect logic comes in Plan 02-02.

Output: src/ws.rs with Trade struct + connect_once function; Cargo.toml updated with serde/serde_json; src/main.rs drives a single connection attempt.
</objective>

<execution_context>
@C:/Users/oresp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/oresp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-scaffold/01-02-SUMMARY.md
@src/config.rs
@src/main.rs
@Cargo.toml
@example_data/websocket_request.txt
@example_data/create_trade_subscription.txt
@example_data/create_trade_response.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add serde dependencies and implement ws.rs with Trade struct and connect_once</name>
  <files>Cargo.toml, src/ws.rs</files>
  <action>
**Step 1: Update Cargo.toml**

Add under `[dependencies]`:
```toml
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

No other changes to Cargo.toml.

**Step 2: Create src/ws.rs**

Implement the following:

```rust
use crate::config::Config;
use serde::Deserialize;
use std::time::Duration;
use tokio_tungstenite::{
    connect_async_tls_with_config,
    tungstenite::{
        client::IntoClientRequest,
        Message,
    },
    Connector,
};
use futures_util::{SinkExt, StreamExt};

// --- Trade types (Phase 3 interface) ---

#[derive(Debug, Clone)]
pub struct Trade {
    pub id: String,
    pub markup_percent: f64,
    pub total_value: f64,
    pub can_join: bool,
    pub status: String,
    // From tradeItems[0]
    pub market_name: String,
    pub brand: String,
    pub skin_name: String,
    pub wear: String,
    pub is_stattrak: bool,
}

// --- Internal deserialization types ---

#[derive(Deserialize, Debug)]
struct WsMessage {
    #[serde(rename = "type")]
    msg_type: String,
    payload: Option<serde_json::Value>,
}

// --- Connection ---

const WS_URL: &str = "wss://router.csgoroll.com/ws";

/// Single connection attempt. Opens WS, completes graphql-transport-ws handshake,
/// then calls on_trade for each received Trade until the connection closes or errors.
/// Returns Ok(()) if connection closed cleanly, Err on protocol/network error.
pub async fn connect_once(
    config: &Config,
    mut on_trade: impl FnMut(Trade),
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // Build the upgrade request with required headers
    let mut request = WS_URL.into_client_request()?;
    let headers = request.headers_mut();
    headers.insert(
        "Sec-WebSocket-Protocol",
        "graphql-transport-ws".parse()?,
    );
    headers.insert(
        "Origin",
        "https://www.csgoroll.com".parse()?,
    );
    headers.insert(
        "Cookie",
        config.csgoroll_session.parse()?,
    );
    headers.insert(
        "User-Agent",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36".parse()?,
    );

    println!("[ws] Connecting to {}...", WS_URL);
    let (mut ws, _response) = connect_async_tls_with_config(
        request,
        None,
        false,
        Some(Connector::NativeTls(
            native_tls::TlsConnector::builder().build()?,
        )),
    )
    .await?;
    println!("[ws] Connected. Sending connection_init...");

    // 1. Send connection_init with auth token
    let init_msg = serde_json::json!({
        "type": "connection_init",
        "payload": {
            "token": config.csgoroll_api_token
        }
    });
    ws.send(Message::Text(init_msg.to_string())).await?;

    // 2. Wait for connection_ack
    loop {
        match ws.next().await {
            Some(Ok(Message::Text(text))) => {
                let parsed: WsMessage = serde_json::from_str(&text)?;
                match parsed.msg_type.as_str() {
                    "connection_ack" => {
                        println!("[ws] connection_ack received. Subscribing...");
                        break;
                    }
                    "connection_error" => {
                        return Err(format!("connection_error: {:?}", parsed.payload).into());
                    }
                    other => {
                        println!("[ws] Unexpected message before ack: {}", other);
                    }
                }
            }
            Some(Ok(Message::Ping(data))) => {
                ws.send(Message::Pong(data)).await?;
            }
            Some(Ok(_)) => {}
            Some(Err(e)) => return Err(e.into()),
            None => return Err("Connection closed before connection_ack".into()),
        }
    }

    // 3. Send subscribe message
    // The subscription query is the exact OnCreateTrades subscription.
    // userId is passed as null — the server sends all public trades without it.
    let subscribe_msg = serde_json::json!({
        "id": "1",
        "type": "subscribe",
        "payload": {
            "variables": {
                "userId": null
            },
            "extensions": {},
            "operationName": "OnCreateTrades",
            "query": "subscription OnCreateTrades($userId: ID, $marketName: String, $maxMarkupPercent: Float, $maxPrice: UnsignedFloat, $minPrice: UnsignedFloat, $maxAvgPaintWear: UnsignedFloat, $minAvgPaintWear: UnsignedFloat, $activeSince: SequelizeDate, $activeUntil: SequelizeDate, $trackingTypeGroup: TradeTrackingTypeGroup, $categoryIds: [ID!], $stickersAppliedCount: Int, $rarities: [String!]) {\n  createTrades(\n    userId: $userId\n    marketName: $marketName\n    maxMarkupPercent: $maxMarkupPercent\n    maxPrice: $maxPrice\n    minPrice: $minPrice\n    maxAvgPaintWear: $maxAvgPaintWear\n    minAvgPaintWear: $minAvgPaintWear\n    activeSince: $activeSince\n    activeUntil: $activeUntil\n    trackingTypeGroup: $trackingTypeGroup\n    categoryIds: $categoryIds\n    stickersAppliedCount: $stickersAppliedCount\n    rarities: $rarities\n  ) {\n    trades {\n      ...SimpleTrade\n      __typename\n    }\n    __typename\n  }\n}\n\nfragment SimpleTrade on Trade {\n  id\n  depositorLastActiveAt\n  markupPercent\n  totalValue\n  avgPaintWear\n  hasStickers\n  tradeItems {\n    ...SimpleTradeItem\n    __typename\n  }\n  trackingType\n  avgPaintWearRange {\n    min\n    max\n    __typename\n  }\n  canJoinAfter\n  depositor {\n    id\n    steamDisplayName\n    steamId\n    __typename\n  }\n  suspectedTraderCanJoinAfter\n  status\n  steamAppName\n  customValue\n  createdAt\n  updatedAt\n  canJoin\n  expiresAt\n  withdrawer {\n    id\n    steamId\n    steamDisplayName\n    steamLevel\n    avatar\n    steamRegistrationDate\n    name\n    __typename\n  }\n  joinedAt\n  cancelReason\n  withdrawerSteamTradeUrl\n  __typename\n}\n\nfragment SimpleTradeItem on TradeItem {\n  id\n  marketName\n  markupPercent\n  customValue\n  steamExternalAssetId\n  itemVariant {\n    ...SimpleTradeItemVariant\n    __typename\n  }\n  stickers {\n    ...SimpleTradeItemSticker\n    __typename\n  }\n  value\n  patternPercentage\n  __typename\n}\n\nfragment SimpleTradeItemVariant on ItemVariant {\n  brand\n  color\n  name\n  iconUrl\n  rarity\n  depositable\n  itemId\n  id\n  value\n  currency\n  externalId\n  __typename\n}\n\nfragment SimpleTradeItemSticker on TradeItemSticker {\n  imageUrl\n  id\n  name\n  color\n  wear\n  brand\n  __typename\n}"
        }
    });
    ws.send(Message::Text(subscribe_msg.to_string())).await?;
    println!("[ws] Subscribe sent. Waiting for trade events...");

    // 4. Receive loop
    loop {
        match ws.next().await {
            Some(Ok(Message::Text(text))) => {
                if let Ok(msg) = serde_json::from_str::<WsMessage>(&text) {
                    match msg.msg_type.as_str() {
                        "next" => {
                            if let Some(payload) = msg.payload {
                                if let Some(trades_arr) = payload
                                    .get("data")
                                    .and_then(|d| d.get("createTrades"))
                                    .and_then(|ct| ct.get("trades"))
                                    .and_then(|t| t.as_array())
                                {
                                    for trade_val in trades_arr {
                                        if let Some(trade) = parse_trade(trade_val) {
                                            on_trade(trade);
                                        }
                                    }
                                }
                            }
                        }
                        "ping" => {
                            // graphql-transport-ws protocol ping: respond with pong
                            let pong = serde_json::json!({"type": "pong"});
                            let _ = ws.send(Message::Text(pong.to_string())).await;
                        }
                        "error" => {
                            eprintln!("[ws] Subscription error: {:?}", msg.payload);
                        }
                        "complete" => {
                            println!("[ws] Subscription completed by server.");
                            return Ok(());
                        }
                        other => {
                            // Ignore unknown message types silently (e.g. ka heartbeats)
                            let _ = other;
                        }
                    }
                }
            }
            Some(Ok(Message::Ping(data))) => {
                let _ = ws.send(Message::Pong(data)).await;
            }
            Some(Ok(Message::Close(_))) => {
                println!("[ws] Server closed connection.");
                return Ok(());
            }
            Some(Ok(_)) => {}
            Some(Err(e)) => return Err(e.into()),
            None => {
                println!("[ws] Connection stream ended.");
                return Ok(());
            }
        }
    }
}

fn parse_trade(val: &serde_json::Value) -> Option<Trade> {
    let id = val.get("id")?.as_str()?.to_string();
    let markup_percent = val.get("markupPercent")?.as_f64()?;
    let total_value = val.get("totalValue")?.as_f64()?;
    let can_join = val.get("canJoin")?.as_bool()?;
    let status = val.get("status")?.as_str()?.to_string();

    let items = val.get("tradeItems")?.as_array()?;
    let item = items.first()?;

    let market_name = item.get("marketName")?.as_str()?.to_string();
    let variant = item.get("itemVariant")?;
    let brand = variant.get("brand")?.as_str()?.to_string();
    let skin_name = variant.get("name")?.as_str()?.to_string();
    let wear = variant.get("color")?.as_str()?.to_string();

    let is_stattrak = market_name.starts_with("StatTrak\u{2122}");

    Some(Trade {
        id,
        markup_percent,
        total_value,
        can_join,
        status,
        market_name,
        brand,
        skin_name,
        wear,
        is_stattrak,
    })
}
```

**Notes on implementation choices:**
- `connect_async_tls_with_config` with `Connector::NativeTls` is used instead of `connect_async` to explicitly use native-tls (consistent with Phase 1 decision; avoids OpenSSL issues on Windows).
- `native_tls` crate is a transitive dependency of `tokio-tungstenite` with `native-tls` feature — it is already available, no need to add to Cargo.toml.
- `futures_util` is a transitive dependency of `tokio-tungstenite` — already available.
- `userId: null` is passed in subscription variables — this omits the per-user filter, so the feed receives all public trade listings. If the server rejects null, use the `userId` value from `example_data/create_trade_subscription.txt` as a fallback hardcoded string (but null should work for the public feed).
- The query string is copied verbatim from `example_data/create_trade_subscription.txt` with JSON escaping.
- `parse_trade` returns None (skips silently) if any required field is missing — defensive, never panics on unexpected server data.

After writing both files, run `cargo build` to confirm no compile errors.
  </action>
  <verify>
    <automated>cd C:/Users/oresp/Desktop/ActuallyRollingInMoney && cargo build 2>&1 | tail -5</automated>
    <manual>Build output ends with "Finished" or "Compiling csgoroll-sniper". Zero errors.</manual>
  </verify>
  <done>cargo build succeeds. src/ws.rs exists with pub struct Trade and pub async fn connect_once. Cargo.toml contains serde and serde_json dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Wire connect_once into main.rs and verify live trade events print to stdout</name>
  <files>src/main.rs</files>
  <action>
Update `src/main.rs` to call `ws::connect_once` and print received trades. Replace the current content with:

```rust
mod config;
mod ws;

#[tokio::main]
async fn main() {
    let config = config::Config::load();

    println!("[main] Starting WebSocket connection...");

    match ws::connect_once(&config, |trade| {
        println!(
            "[trade] id={} markup={:.2}% price={:.2} canJoin={} status={} item=\"{}\" stattrak={}",
            trade.id,
            trade.markup_percent,
            trade.total_value,
            trade.can_join,
            trade.status,
            trade.market_name,
            trade.is_stattrak,
        );
    })
    .await
    {
        Ok(()) => println!("[main] Connection closed cleanly."),
        Err(e) => eprintln!("[main] Connection error: {}", e),
    }
}
```

Key changes from Phase 1:
- `_config` renamed to `config` (no underscore — fields are now consumed)
- `mod ws;` declared
- `ws::connect_once` called with a closure that prints each received trade

Run `cargo build` after writing. This task does NOT run the binary (requires real credentials in .env).
  </action>
  <verify>
    <automated>cd C:/Users/oresp/Desktop/ActuallyRollingInMoney && cargo build 2>&1 | tail -5</automated>
    <manual>Build succeeds with zero errors. "warning: unused variable" on _config is gone (renamed to config). The dead_code warnings on Config fields should also be gone now that fields are consumed.</manual>
  </verify>
  <done>cargo build succeeds. src/main.rs calls ws::connect_once. No unused variable warnings on config. Binary compiles successfully.</done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo build` exits 0 with no errors
2. `src/ws.rs` exists and contains `pub struct Trade`, `pub async fn connect_once`
3. `src/main.rs` contains `mod ws;` and calls `ws::connect_once`
4. `Cargo.toml` contains `serde` and `serde_json`
5. No compiler errors (warnings acceptable — e.g., unused fields in Trade until Phase 3)

Live connection test (requires .env with valid credentials):
- `cargo run` should print `[ws] Connecting...`, `[ws] connection_ack received`, `[ws] Subscribe sent`, then `[trade]` lines as events arrive
- This is manual verification only — automated build check is the gate
</verification>

<success_criteria>
- cargo build exits 0 (zero errors)
- Trade struct has all nine fields Phase 3 needs (id, markup_percent, total_value, can_join, status, market_name, brand, skin_name, wear, is_stattrak)
- connect_once signature matches Phase 3 interface: async fn connect_once(config: &Config, on_trade: impl FnMut(Trade))
- parse_trade correctly maps tradeItems[0].itemVariant.brand/name/color and detects StatTrak from market_name prefix
</success_criteria>

<output>
After completion, create `.planning/phases/02-websocket-connection/02-01-SUMMARY.md`
</output>
