---
phase: 02-websocket-connection
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/ws.rs
  - src/main.rs
autonomous: true
requirements:
  - CONN-01

must_haves:
  truths:
    - "When connection drops, bot automatically reconnects without process restart"
    - "Reconnect delays follow exponential backoff: 1s, 2s, 4s, 8s... capped at 60s"
    - "Backoff delay is observable in stdout logs"
    - "run_with_reconnect is callable from Phase 3 with impl FnMut(Trade) callback"
    - "Backoff resets to 1s after a connection that receives at least one message successfully"
  artifacts:
    - path: "src/ws.rs"
      provides: "run_with_reconnect public function alongside connect_once"
      contains: "pub async fn run_with_reconnect"
    - path: "src/main.rs"
      provides: "Driver calling run_with_reconnect"
      contains: "ws::run_with_reconnect"
  key_links:
    - from: "src/ws.rs run_with_reconnect"
      to: "src/ws.rs connect_once"
      via: "loop { connect_once(...).await; backoff }"
      pattern: "connect_once.*await"
    - from: "src/main.rs"
      to: "ws::run_with_reconnect"
      via: "direct await call"
      pattern: "run_with_reconnect"
---

<objective>
Add exponential backoff reconnect wrapper to the ws module, making the WebSocket connection persistent and self-healing.

Purpose: A bot that exits on network interruption is not production-viable. This plan wraps connect_once in a retry loop with exponential backoff so the bot survives disconnects, server restarts, and network blips without human intervention.

Output: run_with_reconnect function in src/ws.rs; main.rs updated to use it instead of connect_once.
</objective>

<execution_context>
@C:/Users/oresp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/oresp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-websocket-connection/02-01-SUMMARY.md
@src/ws.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add run_with_reconnect to src/ws.rs with exponential backoff</name>
  <files>src/ws.rs</files>
  <action>
Add the following to `src/ws.rs` (append after the existing `connect_once` and `parse_trade` functions — do NOT modify connect_once):

```rust
/// Runs the WebSocket connection indefinitely, reconnecting with exponential backoff on any error.
///
/// Backoff schedule: 1s → 2s → 4s → 8s → 16s → 32s → 60s (capped).
/// Backoff resets to 1s after a connection attempt that successfully received at least one trade.
///
/// This function never returns under normal operation. It only returns if the caller's
/// on_trade closure panics (which it should not).
pub async fn run_with_reconnect(
    config: &Config,
    mut on_trade: impl FnMut(Trade),
) {
    const BACKOFF_CAP_SECS: u64 = 60;
    const BACKOFF_RESET_SECS: u64 = 1;
    let mut delay_secs: u64 = BACKOFF_RESET_SECS;

    loop {
        // Wrap on_trade to track whether we received at least one trade this attempt
        let mut received_count: u32 = 0;
        let result = connect_once(config, |trade| {
            received_count += 1;
            on_trade(trade);
        })
        .await;

        match result {
            Ok(()) => {
                // Clean close — server closed the connection
                println!("[ws] Connection closed cleanly. Reconnecting in {}s...", delay_secs);
            }
            Err(e) => {
                eprintln!("[ws] Connection error: {}. Reconnecting in {}s...", e, delay_secs);
            }
        }

        // Reset backoff if this connection was productive
        if received_count > 0 {
            delay_secs = BACKOFF_RESET_SECS;
            println!("[ws] Productive session ({} trades). Backoff reset to 1s.", received_count);
        }

        tokio::time::sleep(Duration::from_secs(delay_secs)).await;

        // Advance backoff for next failure (only advances if we didn't reset)
        if received_count == 0 {
            delay_secs = (delay_secs * 2).min(BACKOFF_CAP_SECS);
        }
    }
}
```

Add `use tokio::time::Duration;` at the top if `Duration` is not already in scope. Verify `use std::time::Duration` is already there from Task 1 of plan 02-01 — if so, the `tokio::time::sleep` call just needs `tokio::time::sleep(Duration::from_secs(...))` which works with `std::time::Duration`.

After writing, run `cargo build` to confirm no errors.
  </action>
  <verify>
    <automated>cd C:/Users/oresp/Desktop/ActuallyRollingInMoney && cargo build 2>&1 | tail -5</automated>
    <manual>Build succeeds. src/ws.rs contains pub async fn run_with_reconnect. No compile errors.</manual>
  </verify>
  <done>cargo build exits 0. run_with_reconnect is present in src/ws.rs with backoff logic: delay starts at 1s, doubles each failed attempt, caps at 60s, resets to 1s after productive connection.</done>
</task>

<task type="auto">
  <name>Task 2: Update main.rs to use run_with_reconnect as the production driver</name>
  <files>src/main.rs</files>
  <action>
Replace `src/main.rs` content with the production driver using `run_with_reconnect`:

```rust
mod config;
mod ws;

#[tokio::main]
async fn main() {
    let config = config::Config::load();

    println!("[main] CSGORoll Sniper starting persistent WebSocket loop...");

    ws::run_with_reconnect(&config, |trade| {
        println!(
            "[trade] id={} markup={:.2}% price={:.2} canJoin={} status={} item=\"{}\" stattrak={}",
            trade.id,
            trade.markup_percent,
            trade.total_value,
            trade.can_join,
            trade.status,
            trade.market_name,
            trade.is_stattrak,
        );
    })
    .await;
}
```

This replaces the one-shot `connect_once` call with the persistent `run_with_reconnect` loop. The print closure is identical — Phase 3 will replace the println with the whitelist evaluation call.

After writing, run `cargo build` to confirm no errors.
  </action>
  <verify>
    <automated>cd C:/Users/oresp/Desktop/ActuallyRollingInMoney && cargo build 2>&1 | tail -5</automated>
    <manual>Build succeeds. src/main.rs calls ws::run_with_reconnect. No unused import or variable warnings introduced.</manual>
  </verify>
  <done>cargo build exits 0. main.rs calls run_with_reconnect. The bot is now a persistent process: it connects, receives trades, reconnects on any drop, and never exits on its own.</done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo build` exits 0 with no errors
2. `grep -n "run_with_reconnect" src/ws.rs src/main.rs` shows presence in both files
3. Backoff logic: `delay_secs * 2` with `.min(60)` cap is present in src/ws.rs
4. `received_count > 0` reset guard is present

Manual reconnect verification (requires live credentials and network manipulation):
- Run `cargo run` with valid .env → trades print
- Kill network (e.g., disable adapter) → bot prints reconnect message with delay
- Re-enable network → bot reconnects and resumes printing trades
- Observe logs showing "Reconnecting in 1s...", then "Reconnecting in 2s..." if connection fails consecutively
</verification>

<success_criteria>
- cargo build exits 0 (zero errors, zero new warnings)
- run_with_reconnect signature: pub async fn run_with_reconnect(config: &Config, on_trade: impl FnMut(Trade))
- Backoff schedule implemented: 1 → 2 → 4 → 8 → 16 → 32 → 60 (capped), resets after productive session
- main.rs uses run_with_reconnect (not connect_once) as the production entry point
- Phase 3 can call run_with_reconnect with its own whitelist-evaluating closure by replacing the println! closure
</success_criteria>

<output>
After completion, create `.planning/phases/02-websocket-connection/02-02-SUMMARY.md`
</output>
