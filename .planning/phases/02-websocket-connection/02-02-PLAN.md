---
phase: 02-websocket-connection
plan: 02
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/ws.rs
  - src/main.rs
autonomous: true
requirements:
  - CONN-01

must_haves:
  truths:
    - "When the WebSocket connection drops, the bot reconnects automatically without process restart"
    - "Reconnect delay doubles on each consecutive failure: 1s, 2s, 4s, 8s, ... capped at 60s"
    - "Each reconnect attempt logs its attempt number and delay before sleeping"
    - "After a successful reconnect the backoff counter resets to 1s"
    - "The receive loop resumes delivering listing frames after reconnect"
  artifacts:
    - path: "src/ws.rs"
      provides: "run_with_reconnect() function wrapping connect() in an exponential backoff loop"
      min_lines: 90
      exports: ["connect", "run_with_reconnect", "WsStream"]
    - path: "src/main.rs"
      provides: "Calls ws::run_with_reconnect instead of ws::connect directly"
      contains: "run_with_reconnect"
  key_links:
    - from: "src/main.rs"
      to: "src/ws.rs"
      via: "ws::run_with_reconnect(&config, on_frame).await"
      pattern: "run_with_reconnect"
    - from: "src/ws.rs run_with_reconnect"
      to: "src/ws.rs connect"
      via: "calls connect() on every attempt, resets delay on success"
      pattern: "connect\\(&config\\)"
---

<objective>
Add exponential backoff reconnect logic to the WebSocket module, wrapping the connect-and-receive loop so the bot automatically recovers from any disconnect without a process restart.

Purpose: A production-grade live feed must tolerate network interruptions. This makes CONN-01 fully satisfied — the "persistent, auto-reconnecting connection with exponential backoff" requirement.
Output: src/ws.rs extended with run_with_reconnect(); src/main.rs updated to call it.
</objective>

<execution_context>
@C:/Users/oresp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/oresp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-websocket-connection/02-01-SUMMARY.md
@src/ws.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add run_with_reconnect to src/ws.rs with exponential backoff</name>
  <files>src/ws.rs</files>
  <action>
Add a `pub async fn run_with_reconnect` function to src/ws.rs. This function owns the full connect-receive-reconnect lifecycle.

**Function signature:**
```rust
/// Runs the WebSocket receive loop with automatic exponential backoff reconnect.
/// Calls `on_frame` for every Socket.IO event frame (text starting with "42").
/// Never returns unless the process is killed.
pub async fn run_with_reconnect<F>(
    config: &crate::config::Config,
    mut on_frame: F,
) where
    F: FnMut(&str),
{
```

**Backoff parameters (compile-time constants at top of file):**
```rust
const BACKOFF_BASE_SECS: u64 = 1;
const BACKOFF_MAX_SECS: u64 = 60;
```

**Loop structure:**
```rust
let mut delay_secs = BACKOFF_BASE_SECS;
let mut attempt: u32 = 0;

loop {
    if attempt > 0 {
        eprintln!("[ws] Reconnect attempt {} — waiting {}s", attempt, delay_secs);
        tokio::time::sleep(tokio::time::Duration::from_secs(delay_secs)).await;
        // Exponential backoff: double, cap at max
        delay_secs = (delay_secs * 2).min(BACKOFF_MAX_SECS);
    }
    attempt += 1;

    eprintln!("[ws] Connecting (attempt {})...", attempt);
    let stream = match connect(config).await {
        Ok(s) => {
            eprintln!("[ws] Connected and authenticated (attempt {}).", attempt);
            delay_secs = BACKOFF_BASE_SECS; // reset on success
            s
        }
        Err(e) => {
            eprintln!("[ws] Connection error: {}", e);
            continue; // go to top of loop, sleep, retry
        }
    };

    // Run receive loop until disconnected
    receive_loop(stream, &mut on_frame).await;

    eprintln!("[ws] Disconnected. Will reconnect.");
    // loop continues, attempt increments, delay applied
}
```

**Extract receive_loop as a private async fn:**
Move the receive loop logic from main.rs (added in Plan 02-01) into a private function in ws.rs:
```rust
async fn receive_loop<F>(stream: WsStream, on_frame: &mut F)
where
    F: FnMut(&str),
{
    use futures_util::{SinkExt, StreamExt};
    use tokio_tungstenite::tungstenite::Message;

    let (mut write, mut read) = stream.split();

    // Spawn Socket.IO keepalive ping task
    let ping_task = tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(25));
        loop {
            interval.tick().await;
            if write.send(Message::Text("2".to_string())).await.is_err() {
                break;
            }
        }
    });

    while let Some(msg) = read.next().await {
        match msg {
            Ok(Message::Text(text)) => {
                if text.starts_with("42") {
                    on_frame(&text);
                } else {
                    eprintln!("[ws] frame: {}", &text[..text.len().min(120)]);
                }
            }
            Ok(Message::Close(frame)) => {
                eprintln!("[ws] Server closed: {:?}", frame);
                break;
            }
            Ok(_) => {}
            Err(e) => {
                eprintln!("[ws] Receive error: {}", e);
                break;
            }
        }
    }

    ping_task.abort();
}
```

**Hot path note:** The `on_frame` closure is called on every `42` frame — it MUST NOT do disk I/O. Main.rs will pass a closure that only prints to stdout (Phase 2) or calls the whitelist engine (Phase 3). No allocations inside on_frame in this phase beyond what println! does.

**Keep connect() public** — Phase 3 integration tests may call it directly. run_with_reconnect is the production entry point; connect is the building block.
  </action>
  <verify>
    <automated>cargo build 2>&amp;1 | tail -5</automated>
    <manual>Verify src/ws.rs contains run_with_reconnect, receive_loop, BACKOFF_BASE_SECS=1, BACKOFF_MAX_SECS=60 constants, and that delay_secs doubles on each iteration and resets to 1 on successful connect</manual>
  </verify>
  <done>
    `cargo build` exits 0. src/ws.rs exports run_with_reconnect() with exponential backoff logic. BACKOFF_BASE_SECS=1, BACKOFF_MAX_SECS=60 constants defined. receive_loop extracted as private fn. on_frame closure called for every "42" prefixed frame.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update main.rs to use run_with_reconnect with first-frame logging</name>
  <files>src/main.rs</files>
  <action>
Replace the inline receive loop in main.rs with a call to `ws::run_with_reconnect`. Main.rs becomes the thin driver; all connection logic lives in ws.rs.

**Replace main body with:**
```rust
mod config;
mod ws;

#[tokio::main]
async fn main() {
    let config = config::Config::load();

    eprintln!("[main] Starting CSGORoll WebSocket feed...");

    let mut first_listing_printed = false;

    ws::run_with_reconnect(&config, |frame| {
        // frame is a Socket.IO event: starts with "42"
        if !first_listing_printed {
            println!("[ws] First listing event: {}", &frame[..frame.len().min(200)]);
            first_listing_printed = true;
        }
        // All subsequent frames: log to stderr (truncated)
        eprintln!("[ws] event: {}", &frame[..frame.len().min(120)]);
    })
    .await;
}
```

**Note on first_listing_printed:** The closure captures `first_listing_printed` by mutable reference. In Rust, closures passed to `run_with_reconnect` as `FnMut(&str)` can capture `&mut bool` cleanly. If the borrow checker objects to the `move` semantics, use:
```rust
let mut first_listing_printed = false;
ws::run_with_reconnect(&config, move |frame| {
    // This uses the closure's own copy of first_listing_printed
    ...
}).await;
```
The `move` form is fine since `first_listing_printed` is a `bool` (Copy). After reconnect the first-listing flag will remain true, which is correct behavior.

**Remove all inline WebSocket code** that was added in Plan 02-01's Task 2 — the stream split, ping spawn, and receive while loop. ws.rs now owns all of that.

**Final main.rs should be ~20 lines total.** Clean, no WebSocket details visible.
  </action>
  <verify>
    <automated>cargo build 2>&amp;1 | tail -5</automated>
    <manual>
      Optional live test (requires .env with real credentials):
        cargo run 2>&amp;1 | head -20
      Expected output pattern:
        [config] All credentials loaded: ...
        [main] Starting CSGORoll WebSocket feed...
        [ws] Connecting (attempt 1)...
        [ws] Connected and authenticated (attempt 1).
        [ws] frame: 0{"sid":"...","upgrades":[],...}     <- OPEN
        [ws] frame: 40{"sid":"..."}                      <- CONNECT confirmed
        [ws] First listing event: 42["new-item",{...}]

      Reconnect test (optional, requires live connection):
        Run cargo run, wait for connection, then: kill -9 $(pgrep csgoroll-sniper) or block network
        Re-run — observe "[ws] Reconnect attempt 1 — waiting 1s" then "waiting 2s" then "waiting 4s"
    </manual>
  </verify>
  <done>
    `cargo build` exits 0. src/main.rs is a clean ~20-line driver calling ws::run_with_reconnect with a closure that prints the first listing frame. No inline WebSocket code remains in main.rs. The binary, when run with valid credentials, connects, prints the first listing event, and would reconnect with exponential backoff on disconnect.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` exits 0
2. `cargo clippy -- -D warnings` exits 0 (or only dead_code on config fields — expected, resolves in Phase 3)
3. src/ws.rs contains: `pub async fn run_with_reconnect`, `pub async fn connect`, `pub type WsStream`, `async fn receive_loop`, `const BACKOFF_BASE_SECS: u64 = 1`, `const BACKOFF_MAX_SECS: u64 = 60`
4. src/main.rs contains: `ws::run_with_reconnect` call and nothing else WebSocket-related
5. Backoff sequence is 1s → 2s → 4s → 8s → 16s → 32s → 60s (capped) — verifiable by reading the loop logic
6. On successful connect, delay_secs resets to BACKOFF_BASE_SECS (1) — verifiable by reading ws.rs
</verification>

<success_criteria>
- `cargo build` exits 0
- CONN-01 fully satisfied: persistent connection with auto-reconnect and exponential backoff (1s, 2s, 4s, ..., 60s cap)
- run_with_reconnect is the public API that Phase 3 will call with its whitelist-matching closure
- The receive loop in receive_loop() calls on_frame only for "42" prefixed frames — zero disk I/O on the hot path
- Reconnect logs include attempt number and delay (observable in stderr): "[ws] Reconnect attempt N — waiting Xs"
- Phase 3 can replace the on_frame closure with whitelist engine logic with no changes to ws.rs
</success_criteria>

<output>
After completion, create `.planning/phases/02-websocket-connection/02-02-SUMMARY.md`
</output>
